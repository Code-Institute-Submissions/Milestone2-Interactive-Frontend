<h1> Remarks on functions of thememorygame.js </h1>

<h2> Global var and let </h2>

The declared, global variables are straight forward and named according to purpose.

 
<h2> function fieldInit(num) </h2>

This is the major function to generate the playfield. Before working on the generation, the cards are made invisible. I saw some flickering on initial startup of the game when the cards are being created. Thats why I have set the entire playfield to opacity 0.
Those many setTimeout functions are needed to wait for css transition to finish.
It then calls function to have the DOM elements created, set the cardsize and assign class names from mastercard to cards on playfield.
Finally playfield is made visible again.

  
<h2> function generateCards(num) </h2>  
    
Function is called with amount of cards as a parameter.
It clears first all elements from playfield and then runs through a loop for the amount of cards needed to be generated.
When generating the playfield for 8-cards there is this special case to have a dummy cardshell element appended after 4 cards have been generated (to keep the grid 3 x 3 cards). This is placed in the middle of playfield and has the same proportions as all other cards.
Afterwards each generated card gets two elements appended, front and back card face.
    

<h2> function setCardshellSize(num) </h2>  

The default card size is set for 8-card playfield. To fit more cards in same playfield size, cards have to shrink to fit.
So this function sets the card dimensions to either 1/3, 1/4, 1/6 of playfield size. A little bit less, because there needs to be space between the cards.
The flex container with justify-content and align-items set to 'space-around' spreads the cards nicely across playfield.
In addition for each playfield, CardRowlength is set accordingly for calculation of players logo on card.


<h2> function prepAndDeliverCardArray(num) </h2>  

This function copies the master array which contains class names for 18-pairs of cards, in total 36 cards. The DOM card elements of playfield earlier generated by generateCards function are then collected into the array playFieldCardArray. The copy of master card array, currentCardArray is reduced to fit amount of cards of playFieldCardArray by using split function. After applying a random sort on the currentCardArray, those shuffeled class names are then written to each card element  of playFieldCardArray by using a loop.   
   
   
<h2> function checkForMatch() </h2>  
   
The idea for this logic is, to add a class 'showMe' to make cards turn and a second class 'taken' to mark them for current player's choice, every time when a card is clicked. As per design, the class names from card array have been added to the backsides of cards (class 'back') 
As soon as two cards have been selected, playfield becomes inactive.
Those two chosen cards, which are part of an array, are being extracted from array and copied into a separate variable to make a comparison.
The class list of each card element is being compared.
In case of a match or no match, the appropriate function is called to handle the implications.


<h2> function matched() </h2>  

After a timer has run out to wait until cards have fully turned, the popup 'match' is shown to the user (maybe this is being removed in a future version, as there is indication enough by seeing the shown card face).
Function to increase points is being called.
The cardshell class is then replaced by a dummy class which removes them from the rest of cards on playfield to keep them out of the logic. Also 'taken' class is removed from matched cards.
In case this is the last pair of cards being made shown up, the function to inform about end of game is called.
If not all cards have been found, the popup for announcing another next try is being called. After short delay playfield becomes active again.


<h2> function notMatched() </h2>  

After cards have entirely turned, popup is show to user to inform about no luck.
Another delay is applied to make it possible to memorize the position of no matching cards.
Cards are turned back by removing classes.
Current player is being changed and whoIsNext popup is called.


<h2> function increasePoints() </h2>  

Depending on the current player, an element with a big checkmark is being appended to the backside of matched cards, but not made visible yet. 
The fontsize needs to be set first. This step is necessary, because setting fontsize relatively to parent container did not work.
The score is internally increased by 1 and value written to DOM element in playerstats.
Finally the big checkmark with correct calculated fontsize is being made visible by adding class 'bubbleIcon'.

Steps are for both players the same.


<h2> function changeFontsizeBigLogo() </h2>  
  
The side length of playfield is being parsed and converted into an integer value.
Depending on the amount of cards in a row of that grid, the size of playfield is being divided by amount of cards. In fact the divider is bigger than amount of cards to make it optically a bit nicer to have some padding or space on card face. 
As the css function to write that value to the property works with strings, the result value plus unit px is then added to resulting string sizeBigLogo and finally assigned to the property 'font-size' of checkmarkPlayer1Big and checkmarkPlayer2Big .


<h2> function changePlayer(str) </h2>

The overloaded parameter of current player is copied first to activePlayer and then altered to the other player.


<h2> function setActivePlayer(str) </h2>

The popup to inform about current player is being moved from below to above playfield (otherwise playfield would not be accessible).
Depending on next player, the indicator for playerstats is set to red, while playerstats field for inactive player is set to grey.
After setting the HTML content of popup accordingly, the popup is displayed by increasing opacity and later made invisible again, then moved back below playfield.


<h2> function changeOpeningPlayer(str) </h2>

The overloaded parameter of player who opened last game, is copied first to currentGameOpenedBy and then altered to the other player to have him or her to start next game.



    // displaying final result of who has won the game
    function gameCompleted() {
        if (scorePlayer1 > scorePlayer2) {
            $('.popupGameCompleted').html(namePlayer1 + " has won!");
        }
        else if (scorePlayer2 > scorePlayer1) {
            $('.popupGameCompleted').html(namePlayer2 + " has won!");
        }
        else if (scorePlayer1 == scorePlayer2) {
            $('.popupGameCompleted').html(namePlayer1 + " and " + namePlayer2 + " have same points!");
        }
        $('.popupGameCompleted').css("transform", "translateZ(150px)").css("z-index", "100").css("opacity", "1.0");
        changeOpeningPlayer(ThisGameOpenedBy);
        setTimeout(function() { // have popup for game completion visible for 4 seconds and then ... 
            $('.popupGameCompleted').css("opacity", "0.0");
            firstAttemptDone = 0;
            makeBtnActiveButStart();
            setTimeout(function() { // wait a little until popup for game completion has vanished and move position in z-space.
                $('.popupGameCompleted').css("transform", "translateZ(-10px)").css("z-index", "-100");
            }, 1200);
        }, 4000);
    }

    // show popup 'whoIsNext'
    function whoIsNext() {
        if (firstAttemptDone == 0 && ThisGameOpenedBy == "Player1") { // on 1st move of game, the ThisGameOpenedBy value is being checked to have each player start every other game
            currentPlayer = "Player1"; // currentPlayer is set to be syncronized accordingly to ThisGameOpenedBy
            setActivePlayer(currentPlayer);
        }
        else if (firstAttemptDone == 0 && ThisGameOpenedBy == "Player2") {
            currentPlayer = "Player2";
            setActivePlayer(currentPlayer);
        }
        else if (firstAttemptDone == 1 && currentPlayer == "Player1") {
            setActivePlayer(currentPlayer);
        }
        else if (firstAttemptDone == 1 && currentPlayer == "Player2") {
            setActivePlayer(currentPlayer);
        }
        firstAttemptDone = 1; // game has been started
    }

    // show popup 'popupMatch'
    function popupMatch() {
        $('.popupMatch').css("transform", "translateZ(400px)").css("z-index", "400");
        setTimeout(function() {
            $('.popupMatch').css("opacity", "1.0");
        }, 300);
        setTimeout(function() {
            $('.popupMatch').css("opacity", "0.0");
        }, 1400);
        setTimeout(function() {
            $('.popupMatch').css("transform", "translateZ(-10px)").css("z-index", "-1");
        }, 2200);
    }

    // show popup 'popupNoMatch'
    function popupNoMatch() {
        $('.popupNoMatch').css("transform", "translateZ(400px)").css("z-index", "400");
        setTimeout(function() {
            $('.popupNoMatch').css("opacity", "1.0");
        }, 300);
        setTimeout(function() {
            $('.popupNoMatch').css("opacity", "0.0");
        }, 1400);
        setTimeout(function() {
            $('.popupNoMatch').css("transform", "translateZ(-10px)").css("z-index", "-1");
        }, 2200);
    }

    // setting color indicator on button for playfield size
    function make_field8BtnVisActive() {
        $(".field8Btn").addClass("selectedSize").removeClass("bg-fieldSizeBtn"); // indicator for selected size
        $(".field16Btn").removeClass("selectedSize").addClass("bg-fieldSizeBtn"); // removing selected size indicator class
        $(".field36Btn").removeClass("selectedSize").addClass("bg-fieldSizeBtn"); // removing selected size indicator class
    }

    function make_field16BtnVisActive() {
        $(".field8Btn").removeClass("selectedSize").addClass("bg-fieldSizeBtn"); // removing selected size indicator class
        $(".field16Btn").addClass("selectedSize").removeClass("bg-fieldSizeBtn"); // indicator for selected size
        $(".field36Btn").removeClass("selectedSize").addClass("bg-fieldSizeBtn"); // removing selected size indicator class
    }

    function make_field36BtnVisActive() {
        $(".field8Btn").removeClass("selectedSize").addClass("bg-fieldSizeBtn"); // removing selected size indicator class
        $(".field16Btn").removeClass("selectedSize").addClass("bg-fieldSizeBtn"); // removing selected size indicator class
        $(".field36Btn").addClass("selectedSize").removeClass("bg-fieldSizeBtn"); // indicator for selected size
    }

    // disabling buttons 
    function makeBtnInactive() {
        // set dimmed state to all buttons except 'how to' and 'stopbutton'
        $(".enterPlayersBtn").addClass("btnlocked");
        $(".field8Btn").addClass("btnlocked");
        $(".field16Btn").addClass("btnlocked");
        $(".field36Btn").addClass("btnlocked");
        $(".startBtn").addClass("btnlocked");
        $(".stopBtn").removeClass("btnlocked"); // stopbutton will become visually active
        // button states
        stopBtnActive = true;
        fieldActive = true;
        btnActive = false;
        startBtnActive = false;
    }

    // removing dimmed button state and to make buttons active ...
    function makeBtnActive() {
        // ... remove dimmed state
        $(".enterPlayersBtn").removeClass("btnlocked");
        $(".field8Btn").removeClass("btnlocked");
        $(".field16Btn").removeClass("btnlocked");
        $(".field36Btn").removeClass("btnlocked");
        // start button
        $(".startBtn").removeClass("btnlocked");
        $(".stopBtn").addClass("btnlocked"); // dimmed state applied when game stopped.
        // button states
        btnActive = true;
        startBtnActive = true;
        stopBtnActive = false;
    }
    
    // reactivate all buttons but start button 
    function makeBtnActiveButStart() {
        // ... remove dimmed state
        $(".enterPlayersBtn").removeClass("btnlocked");
        $(".field8Btn").removeClass("btnlocked");
        $(".field16Btn").removeClass("btnlocked");
        $(".field36Btn").removeClass("btnlocked");
        $(".stopBtn").addClass("btnlocked"); // dimmed state applied when game stopped.
        // button states
        btnActive = true;
        fieldActive = false;
        stopBtnActive = false;
    }

    // reset counters
    function resetCounters() {
        scorePlayer1 = 0;
        $(".scorePlayer1Field").html(scorePlayer1);
        scorePlayer2 = 0;
        $(".scorePlayer2Field").html(scorePlayer2);
    }

    // show signup dialog
    function showRegistrationPopup() {
        $('#enterPlayersModal').css("transform", "translateZ(400px)").css("z-index", "400").css("opacity", "1.0");
    }

    // check and validate entered player names 
    function checkNames() {
        //should either field have string length of 0, or...
        if ($('#nameFieldPlayer1Form').val().length == 0 || $('#nameFieldPlayer2Form').val().length == 0) {
            $('.popupCheckNames').html(`Please fill in names<br> in both fields.`);
            popupCheckNames();
        }
        //...string length of >8, the user will be informed with alert popup
        else if ($('#nameFieldPlayer1Form').val().length > 8 || $('#nameFieldPlayer2Form').val().length > 8) {
            $('.popupCheckNames').html(`Please fill in names with no more than 8 characters.`);
            popupCheckNames();
        }
        //should both fields have same name, the user will be informed with alert popup
        else if ($('#nameFieldPlayer1Form').val() == $('#nameFieldPlayer2Form').val()) {
            $('.popupCheckNames').html(`Please provide different<br> names for each player.`);
            popupCheckNames();
        }
        // in any other case
        else {
            processNames();
        }
    }

    // show popup 'popupCheckNames'
    function popupCheckNames() {
        $('.popupCheckNames').css("transform", "translateZ(500px)").css("z-index", "500");
        setTimeout(function() {
            $('.popupCheckNames').css("opacity", "1.0");
        }, 300);
        setTimeout(function() {
            $('.popupCheckNames').css("opacity", "0.0");
        }, 2200);
        setTimeout(function() {
            $('.popupCheckNames').css("transform", "translateZ(-10px)").css("z-index", "-1");
        }, 3000);
    }

    // string values of textinput fields written to HTML elements and internal variables
    function processNames() {
        namePlayer1 = $('#nameFieldPlayer1Form').val();
        $('.namePlayer1Field').html(namePlayer1 + ": ");
        namePlayer2 = $('#nameFieldPlayer2Form').val();
        $('.namePlayer2Field').html(namePlayer2 + ": ");
        $('#enterPlayersModal').css("opacity", "0.0");
        setTimeout(function() {
            $('#enterPlayersModal').css("transform", "translateZ(-10px)").css("z-index", "-1");
        }, 1000);
    }

    // show popup with game rules
    function showHowToPopup() {
        $('#howToModal').css("transform", "translateZ(400px)").css("z-index", "400").css("opacity", "1.0");
    }

    // code executed on startup:
    window.onresize = function() { changeFontsizeBigLogo(); };
    fieldInit(9);
    make_field8BtnVisActive();
    resetCounters();
    setTimeout(function() { // show registration when playfield is generated
        showRegistrationPopup();
    }, 2000);

    // click events for registration popup button, ...
    $(".enterPlayersBtn").on('click', function() {
        if (btnActive == true) {
            showRegistrationPopup();
        }
    });

    // ... how-to popup button,
    $(".howToBtn").on('click', function() {
        // Howto button is accessible all the time
        showHowToPopup();
    });

    // ... 8-card playfield button,
    $(".field8Btn").on('touchstart click', function() {
        if (btnActive == true) {
            make_field8BtnVisActive();
            fieldInit(9); // initalizing fieldsize 3x3 cards / 4 pairs with one free card in the middle
            resetCounters();
            startBtnActive = true;
            $(".startBtn").removeClass("btnlocked");
        }
    });

    // ... 16-card playfield button,
    $(".field16Btn").on('touchstart click', function() {
        if (btnActive == true) {
            make_field16BtnVisActive();
            fieldInit(16); // initalizing fieldsize 4x4 cards / 8 pairs
            resetCounters();
            startBtnActive = true;
            $(".startBtn").removeClass("btnlocked");
        }
    });

    // ... 36-card playfield button,
    $(".field36Btn").on('touchstart click', function() {
        if (btnActive == true) {
            make_field36BtnVisActive();
            fieldInit(36); // initalizing fieldsize 6x6 cards / 18 pairs
            resetCounters();
            startBtnActive = true;
            $(".startBtn").removeClass("btnlocked");
        }
    });

    // ... start button
    $(".startBtn").on('touchstart click', function() {
        if (startBtnActive == true) {
            makeBtnInactive();
            whoIsNext();
            setTimeout(function() {
                fieldActive = true;
            }, 1200);
        }
    });

    // ... stop button
    $(".stopBtn").on('touchstart click', function() {
        if (stopBtnActive == true) {
            fieldActive = false;
            makeBtnActive();
        }
    });

    // ... cards on playfield
    $(document).on('touchstart click', '.cardshell', function() {
        if (fieldActive == true) {
            $(this).addClass("showMe taken");
            checkForMatch();
        }
    });

    // ack button howTo modal
    $('#gotItBtn').on('touchstart click', function() {
        $('#howToModal').css("opacity", "0.0");
        setTimeout(function() {
            $('#howToModal').css("transform", "translateZ(-10px)").css("z-index", "-1");
        }, 1000);
    });

    // ... for save button button on registration modal
    $('#saveBtn').on('touchstart click', function() {
        checkNames();
    });
